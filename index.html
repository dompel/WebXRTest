<!DOCTYPE html>
<html>
<head>
    <title>WebXR Exit Button Example</title>
    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://threejs.org/examples/js/loaders/FontLoader.js"></script>
    <script src="https://threejs.org/examples/js/geometries/TextGeometry.js"></script>
    <style>
        body {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        #startButton {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Welcome to the WebXR Exit Button Example</h1>
    <button id="startButton" onclick="activateXR()">Start WebXR</button>

    <script>
        let session;
        let camera, scene, exitButton3D, logTextMesh, renderer, referenceSpace;
        const raycaster = new THREE.Raycaster();

        async function activateXR() {
            if (!navigator.xr) {
                alert("WebXR is not supported on this browser.");
                return;
            }

            const canvas = document.createElement("canvas");
            document.body.appendChild(canvas);
            const gl = canvas.getContext("webgl", { xrCompatible: true });

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera();
            scene.add(camera); // Ensure camera is part of the scene
            camera.matrixAutoUpdate = false;

            // Create cube for reference
            const cube = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.2, 0.2),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 }) // Green for visibility
            );
            cube.position.set(0, 0, -1);
            scene.add(cube);

            // Add exit button
            createExitButton(scene, camera);

            // Add 3D log text inside WebXR
            createLogText(scene);

            renderer = new THREE.WebGLRenderer({ alpha: true, canvas, context: gl });
            renderer.autoClear = false;

            session = await navigator.xr.requestSession("immersive-ar");
            session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

            referenceSpace = await session.requestReferenceSpace("local");

            const onXRFrame = (time, frame) => {
                session.requestAnimationFrame(onXRFrame);
                gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);

                const pose = frame.getViewerPose(referenceSpace);
                if (pose) {
                    const view = pose.views[0];
                    const viewport = session.renderState.baseLayer.getViewport(view);
                    renderer.setSize(viewport.width, viewport.height);

                    camera.matrix.fromArray(view.transform.matrix);
                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                    camera.updateMatrixWorld(true);

                    // Update exit button position
                    if (exitButton3D) {
                        exitButton3D.position.set(
                            camera.position.x + 0.5,
                            camera.position.y + 0.4,
                            camera.position.z - 1.2
                        );
                        exitButton3D.lookAt(camera.position.x, camera.position.y, camera.position.z);
                    }

                    // Update log text position
                    if (logTextMesh) {
                        logTextMesh.position.set(
                            camera.position.x,
                            camera.position.y + 0.6,
                            camera.position.z - 1.5
                        );
                        logTextMesh.lookAt(camera.position.x, camera.position.y, camera.position.z);
                    }

                    renderer.clear();
                    renderer.render(scene, camera);
                }
            };
            session.requestAnimationFrame(onXRFrame);

            session.addEventListener("select", checkExitButtonClick);
        }

        function exitXR() {
            if (session) {
                session.end();
                logMessage("âœ… WebXR session ended.");
            }
        }

        function createExitButton(scene, camera) {
            const exitMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red for visibility
            const exitGeometry = new THREE.PlaneGeometry(0.3, 0.3); // Bigger button
            exitButton3D = new THREE.Mesh(exitGeometry, exitMaterial);

            // Start position in front of camera
            exitButton3D.position.set(0.5, 0.4, -1.2);
            exitButton3D.userData.isExitButton = true;
            scene.add(exitButton3D);

            logMessage("âœ… Exit button added to scene.");
        }

        function createLogText(scene) {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const logTextGeometry = new THREE.TextGeometry("Logs will appear here", {
                    font: font,
                    size: 0.05,
                    height: 0.001
                });

                const logTextMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                logTextMesh = new THREE.Mesh(logTextGeometry, logTextMaterial);

                logTextMesh.position.set(0, 1.5, -1); // Place it at eye level
                scene.add(logTextMesh);
            });
        }

        function logMessage(message) {
            if (!logTextMesh) return;

            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const textGeometry = new THREE.TextGeometry(message, {
                    font: font,
                    size: 0.05,
                    height: 0.001
                });

                logTextMesh.geometry.dispose(); // Clean up old text
                logTextMesh.geometry = textGeometry;
            });
        }

        function checkExitButtonClick(event) {
            if (!session) return;

            const inputSources = session.inputSources;
            if (inputSources.length === 0) return;

            const inputSource = inputSources[0];
            if (!inputSource || !inputSource.targetRaySpace) return;

            session.requestAnimationFrame((time, frame) => {
                if (!referenceSpace) return;
                const pose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                if (!pose) return;

                const rayOrigin = new THREE.Vector3(
                    pose.transform.position.x,
                    pose.transform.position.y,
                    pose.transform.position.z
                );

                const rayDirection = new THREE.Vector3(0, 0, -1);

                raycaster.set(rayOrigin, rayDirection);
                const intersects = raycaster.intersectObjects(scene.children, true);

                for (let i = 0; i < intersects.length; i++) {
                    if (intersects[i].object.userData.isExitButton) {
                        logMessage("ðŸ›‘ Exit button tapped! Exiting XR...");
                        exitXR();
                        return;
                    }
                }
            });
        }
    </script>
</body>
</html>
