<!DOCTYPE html>
<html>
  <head>
    <title>WebXR Interactive Cube (Mobile Support)</title>
    <script src="https://unpkg.com/three@0.126.0/build/three.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/jsm/webxr/XRControllerModelFactory.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/jsm/webxr/XRHandModelFactory.js"></script>
    <style>
      body {
        text-align: center;
        font-family: Arial, sans-serif;
        touch-action: none;
        margin: 0;
        overflow: hidden;
      }
      #startButton, #surveyButton {
        padding: 10px 20px;
        font-size: 18px;
        cursor: pointer;
        background-color: #007BFF;
        color: white;
        border: none;
        border-radius: 5px;
        margin-top: 20px;
        position: absolute;
        z-index: 10;
      }
      #startButton { top: 20px; left: 20px; }
      #surveyButton { top: 20px; right: 20px; display: none; }
    </style>
  </head>
  <body>
    <h1 style="display:none;">Welcome to the Interactive WebXR Application</h1>
    <button id="startButton">Start WebXR</button>
    <button id="surveyButton">Zur체ck zur Umfrage</button>
    
    <script>
      let arStartTime, arActive = false;
      let cube, scene, renderer, camera, session;
      let isDragging = false, previousTouch;
      let isMultiTouch = false, previousDistance = null, previousAngle = null, previousMidpoint = null;
      
      // Helper-Funktionen f체r Multitouch
      function getDistance(touch1, touch2) {
        let dx = touch2.clientX - touch1.clientX;
        let dy = touch2.clientY - touch1.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }
      function getAngle(touch1, touch2) {
        return Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX);
      }
      function getMidpoint(touch1, touch2) {
        return {
          x: (touch1.clientX + touch2.clientX) / 2,
          y: (touch1.clientY + touch2.clientY) / 2
        };
      }
      
      const startButton = document.getElementById("startButton");
      const surveyButton = document.getElementById("surveyButton");
      startButton.style.display = "inline-block";
      
      startButton.onclick = async function () {
        arStartTime = Date.now();
        arActive = true;
        
        // Erstelle und style das Canvas, sodass es den ganzen Bildschirm f체llt
        const canvas = document.createElement("canvas");
        canvas.style.position = "absolute";
        canvas.style.top = "0";
        canvas.style.left = "0";
        canvas.style.width = "100%";
        canvas.style.height = "100%";
        document.body.appendChild(canvas);
        
        // H채nge Touch-Event-Listener direkt an das Canvas
        canvas.addEventListener("touchstart", onTouchStart, false);
        canvas.addEventListener("touchmove", onTouchMove, false);
        canvas.addEventListener("touchend", onTouchEnd, false);
        
        const gl = canvas.getContext("webgl", { xrCompatible: true });
        
        scene = new THREE.Scene();
        renderer = new THREE.WebGLRenderer({ alpha: true, preserveDrawingBuffer: true, canvas: canvas, context: gl });
        renderer.autoClear = false;
        renderer.xr.enabled = true;
        
        camera = new THREE.PerspectiveCamera();
        camera.matrixAutoUpdate = false;
        
        const materials = [
          new THREE.MeshBasicMaterial({ color: 0xff0000 }),
          new THREE.MeshBasicMaterial({ color: 0x0000ff }),
          new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
          new THREE.MeshBasicMaterial({ color: 0xff00ff }),
          new THREE.MeshBasicMaterial({ color: 0x00ffff }),
          new THREE.MeshBasicMaterial({ color: 0xffff00 })
        ];
        cube = new THREE.Mesh(new THREE.BoxBufferGeometry(0.2, 0.2, 0.2), materials);
        cube.position.set(0, 0, -1);
        scene.add(cube);
        
        if (!navigator.xr) {
          alert("WebXR is not supported on this browser.");
          return;
        }
        
        // "hand-tracking" als optionales Feature angefragt
        session = await navigator.xr.requestSession("immersive-ar", { 
          requiredFeatures: ["local-floor"],
          optionalFeatures: ["hand-tracking"]
        });
        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
        const referenceSpace = await session.requestReferenceSpace("local-floor");
        
        renderer.xr.setReferenceSpaceType("local-floor");
        renderer.xr.setSession(session);
        
        const onXRFrame = (time, frame) => {
          if (!session) return;
          session.requestAnimationFrame(onXRFrame);
          gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);
          
          const pose = frame.getViewerPose(referenceSpace);
          if (pose) {
            const view = pose.views[0];
            const viewport = session.renderState.baseLayer.getViewport(view);
            renderer.setSize(viewport.width, viewport.height);
            camera.matrix.fromArray(view.transform.matrix);
            camera.projectionMatrix.fromArray(view.projectionMatrix);
            camera.updateMatrixWorld(true);
            renderer.clear();
            renderer.render(scene, camera);
          }
        };
        
        session.requestAnimationFrame(onXRFrame);
        
        session.addEventListener("end", () => {
          arActive = false;
          session = null;
          const elapsedTime = Math.round((Date.now() - arStartTime) / 1000);
          surveyButton.style.display = "inline-block";
          surveyButton.onclick = () => {
            window.location.href = `https://ww2.unipark.de/uc/Dominik/1db8/ospe.php?return_tic=tic?a=id&b=1&c=${elapsedTime}`;
          };
        });
      };
      
      // Touch-Event-Handler, die direkt am Canvas registriert sind
      function onTouchStart(event) {
        if (!arActive || !cube) return;
        if (event.touches.length === 1) {
          isDragging = true;
          previousTouch = event.touches[0];
        } else if (event.touches.length === 2) {
          isMultiTouch = true;
          previousDistance = getDistance(event.touches[0], event.touches[1]);
          previousAngle = getAngle(event.touches[0], event.touches[1]);
          previousMidpoint = getMidpoint(event.touches[0], event.touches[1]);
        }
      }
      
      function onTouchMove(event) {
        if (!arActive || !cube) return;
        if (isMultiTouch && event.touches.length === 2) {
          const currentDistance = getDistance(event.touches[0], event.touches[1]);
          const currentAngle = getAngle(event.touches[0], event.touches[1]);
          const currentMidpoint = getMidpoint(event.touches[0], event.touches[1]);
          
          // Skalierung (uniform)
          const scaleFactor = currentDistance / previousDistance;
          cube.scale.multiplyScalar(scaleFactor);
          
          // Rotation (um die Y-Achse, kann je nach Bedarf angepasst werden)
          const angleDelta = currentAngle - previousAngle;
          cube.rotation.y += angleDelta;
          
          // Translation anhand der Bewegung des Mittelpunkts
          const deltaX = currentMidpoint.x - previousMidpoint.x;
          const deltaY = currentMidpoint.y - previousMidpoint.y;
          cube.position.x += deltaX * 0.001;
          cube.position.y -= deltaY * 0.001;
          
          previousDistance = currentDistance;
          previousAngle = currentAngle;
          previousMidpoint = currentMidpoint;
        } else if (isDragging && event.touches.length === 1) {
          const touch = event.touches[0];
          const deltaX = touch.clientX - previousTouch.clientX;
          const deltaY = touch.clientY - previousTouch.clientY;
          cube.position.x += deltaX * 0.001;
          cube.position.y -= deltaY * 0.001;
          previousTouch = touch;
        }
      }
      
      function onTouchEnd(event) {
        if (event.touches.length < 2) {
          isMultiTouch = false;
          previousDistance = null;
          previousAngle = null;
          previousMidpoint = null;
        }
        if (event.touches.length === 0) {
          isDragging = false;
        }
      }
    </script>
  </body>
</html>
